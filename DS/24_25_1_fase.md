# Group I

## 1. Evaluating whether a software system has a â€œgoodâ€ design involves measurable indicators and principles that provide objective criteria for assessment.

### (a) What measurable indicators can be used to evaluate if a software design is "good"?

The measurable indicators that can be used to evaluate if a software design is "good" include:

- **Halstead Volume**: This metric mesures the size of the code on the number of operators and operands, estimating the cognitive effort needed to understand the code.
- **Cyclomatic Complexity**: This indicates the number of linearly independent paths through the code, reflecting its logical complexity and potential for errors.
- **Maintainability Index**: A composite metric that assesses how easy it is to maintain the code, factoring in cyclomatic complexity.
- **Information Flow Complexity**: Measures the complexity based on the flow of information between modules, considering how data is passed through the system.
- **Metrics for OO Design**: 
  - **Weighted Methods per Class (WMC)**: Sums the complexity of all methods in a class, indicating the class's complexity.
  - **Depth of Inheritance Tree (DIT)**: Measures how far a class is from the root of the inheritance tree, indicating potential reuse and complexity.
  - **Response For a Class (RFC)**: Counts the number of methods that can be executed in response to a message received by a class, showing its potential interaction complexity.
  - **Number of Children (NOC)**: Tracks how many subclasses inherit from a class, indicating its inheritance hierarchy depth.


### (b) How do software design principles, such as separation of concerns or abstraction, contribute to assessing design quality?

Design principles improve quality by shaping structural properties that can be measured. **Separation of Concerns** increases cohesion and reduces coupling, making modules easier to understand, change, and test, which typically lowers interaction complexity and stabilizes dependencies. **Abstraction and DRY** hide implementation details and eliminate duplication, reducing perâ€‘method and perâ€‘class complexity and improving reuse. These principles lead to designs that are more modular, maintainable, and adaptable, which can be quantitatively assessed using the aforementioned metrics.

---

## 2. Performance is a critical quality attribute in software systems.

### (a) Explain what it consists of.

The performance of a software consists in how efficiently it utilizes the system resources to provide timely responses to any requests. It is often measured in terms of response time, throughput, and resource utilization. Performance is crucial for ensuring that the system can handle the expected load and provide a satisfactory user experience.

### (b) In general, requirements for different quality attributes often conflict with one another. Provide an example of a software system that illustrates potential conflicts between performance and other quality attribute.

An example of a software conflict is related, for example, performance and security. This conflict is evident in systems that require encryption for data transmission. While encryption enhances security by protecting data from unauthorized access, it also introduces additional processing overhead, which can lead to increased response times and reduced throughput. As a result, the system may struggle to meet performance requirements while ensuring data security.

### (c) Consider a system with two independent servers:

- Server1: Availability ð‘Ž1, service rate ð‘ 1
- Server2: Availability ð‘Ž2, service rate ð‘ 2, where ð‘ 1 > ð‘ 2.

Requests are distributed between the two servers based on their availability and the
presented service rates, using a load-balacing strategy:

1) If both are available, requests are routed to the faster server,
2) If only one is available, it handles the requests.

Considering only situations where a response is obtained, calculate the average response time for the system based on the given parameters.

To calculate the average response time for the system, we need to consider the different scenarios based on the availability of the servers.

1. Both servers are available:
   - Probability: ð‘Ž1 * ð‘Ž2
   - Response time: 1/ð‘ 1 (since requests are routed to the faster server)
2. Only Server1 is available:
    - Probability: ð‘Ž1 * (1 - ð‘Ž2) 
    - Response time: 1/ð‘ 1
3. Only Server2 is available:
    - Probability: (1 - ð‘Ž1) * ð‘Ž2
    - Response time: 1/ð‘ 2
     
The average response time (ART) can be calculated as follows:
ART = (ð‘Ž1 * ð‘Ž2 * (1/ð‘ 1)) + (ð‘Ž1 * (1 - ð‘Ž2) * (1/ð‘ 1)) + ((1 - ð‘Ž1) * ð‘Ž2 * (1/ð‘ 2)) / (ð‘Ž1 + ð‘Ž2 - ð‘Ž1 * ð‘Ž2)

   ---

# Group II

SmartSuggest is an e-commerce recommendation system that aims to provide personalized product recommendations to users based on their browsing and purchasing behavior. The system collects real-time user activity data (e.g., product views, clicks, and purchases). It must generate personalized recommendations for each active user in near real-time and periodically produce global trending product lists (daily, weekly, monthly). The recommendations must prioritize performance and scalability to handle thousands of users. The system must allow easy updates to recommendation algorithms and support integration with external analytics tools.

## 1. Choose an architectural style suitable for this system.

### (a) Suggest an architectural style suitable for this system, considering the need for scalability and independent deployment of services. Describe, in abstract terms, the types of components and connectors used. Explain the key advantages and disadvantages of the identified style.

The architectural style suitable for SmartSuggest is the Microservices Architecture combined with Event-Driven Architecture. This style allows for scalability and independent deployment of services devided into distinct components like User Activity Ingestion Service, Recommendation Engine Service, Trending Products Service, and Analytics Integration Service, where each service is responsible for a specific functionality and data processing. This architecture uses asynchronous messaging as connectors, enabling real-time data processing and communication between services together with RESTful APIs for synchronous interactions when necessary.

This kind of architecture offers several advantages:

- **Scalability**: Each microservice can be scaled independently based on demand, allowing for efficient resource utilization.
- **Flexibility**: Services can be developed, deployed, and updated independently, facilitating continuous integration and delivery.
- **Performance and responsiveness**: The event-driven nature allows for real-time processing of user activity data, enhancing the responsiveness of recommendations.
- **Resilience**: Failure in one service does not necessarily impact the entire system, improving overall system reliability.
- **Technology Diversity**: Different services can use different technologies best suited for their specific tasks.

However, there are also some disadvantages:

- **Complexity**: Managing multiple services and their interactions can introduce complexity in deployment, monitoring, testing, and debugging.
- **Data Consistency**: Ensuring data consistency across services can be challenging, especially in an event-driven architecture.
- **Latency**: Asynchronous communication can introduce latency, which may affect real-time performance if not properly managed.

### (b) Design an architecture for the system based on the chosen style. Present a component and connector view illustrating the system's runtime organization. Include a legend and describe all the elements in the diagram, clarifying their roles and responsibilities.

---

## 2. Why is it essential to use multiple architectural views to document a system like SmartSuggest? Provide examples of views that would be relevant and explain their purpose.

Using multiple architectural views is essential for documenting a system like SmartSuggest because it provides a comprehensive understanding of the system from different perspectives, catering to various stakeholders' needs. Each view highlights specific aspects of the architecture, facilitating better communication, analysis, and decision-making this aspects cannot be fully captured in a single view.

Relevant views for SmartSuggest include:

- **Logical/Functional View**: This view focuses on the system's functionality and the organization of the system into components or modules. It helps stakeholders understand what the system does and how responsibilities are distributed.
- **Runtime/Process View**: This view illustrates the system's dynamic aspects, such as the interactions between components during execution, concurrency, and communication patterns. It is useful for understanding performance, scalability, and reliability concerns.
- **Deployment View**: This view shows how the system is physically deployed across hardware and network infrastructure. It is crucial for understanding scalability, fault tolerance, and resource allocation.
- **Data View**: This view focuses on the data structures, databases, and data flow within the system. It helps in understanding how data is managed, stored, and accessed, which is vital for performance and scalability.
- **Security View**: This view addresses the security aspects of the system, including authentication, authorization, and data protection mechanisms. It is essential for ensuring that the system meets security requirements.

---

## 3. Imagine the module responsible for product recommendations needs to be outsourced to an external vendor. What are the advantages of using the architecture identified in 1 (a) compared to other tightly coupled architectures?

---

# Group III

## 1. It is well known that a system's architecture strongly influences different quality attributes.

### (a) Explain the typical structure of a quality scenario and discuss the advantages of using these scenarios to express requirements related to quality attributes.  

A typical quality scenario consists of the following elements:

- **Source of Stimulus**: The entity that generates the stimulus, such as a user or an external system.
- **Stimulus**: The event or condition that triggers the scenario, such as a user request or a system failure.
- **Artifact**: The part of the system that is affected by the stimulus, such as a specific component or service.
- **Environment**: The conditions under which the scenario occurs, such as normal operation or peak load.
- **Response**: The system's behavior in response to the stimulus, such as processing a request or recovering from a failure.
- **Response Measure**: The criteria used to evaluate the system's performance in the scenario, such as response time or throughput.

The usage of this scenarios to express requirements related to quality attributes offers several advantages:

- **Clarity and Precision**: Quality scenarios provide a clear and precise way to specify quality requirements, reducing ambiguity and ensuring that all stakeholders have a shared understanding.
- **Verification and Testability**: They facilitate the verification and testing of quality attributes by providing concrete examples and measurable criteria, in order to validate that the system meets the specified requirements.
- **Design Guidance**: Quality scenarios help guide architectural and design decisions by highlighting critical quality requirements that the system must satisfy.
- **Stakeholder Communication**: Quality scenarios serve as a communication tool among stakeholders, ensuring that everyone has a common understanding of quality requirements and expectations.
- **Impact Analysis**: They assist in impact analysis by identifying how changes in one part of the system might affect quality attributes, helping to manage risks and plan modifications effectively.

### (b) Write two quality scenarios for SmartSuggest: one addressing modifiability and another addressing response time. Explicitly state, if relevant, the expected system load or rate of incoming user activity data.

A **modifiability** quality scenario for SmartSuggest could be:

- **Source of Stimulus**: Developer team
- **Stimulus**: A new recommendation algorithm needs to be integrated into the system.
- **Artifact**: Recommendation Engine Service.
- **Environment**: Normal operation with a normal user activity events.
- **Response**: The system allows the new algorithm to be integrated with minimal changes to existing code and without affecting other services.
- **Response Measure**: The integration of the new algorithm should require no more than 1 day of development time and should not introduce any downtime or performance degradation, and should not require any interruption to the user activity data ingestion process.

A **response time** quality scenario for SmartSuggest could be:

- **Source of Stimulus**: Active end user
- **Stimulus**: A user requests personalized product recommendations while browsing the e-commerce platform.
- **Artifact**: Recommendation Engine Service and Gateway Service.
- **Environment**: High load with thousands of concurrent users generating activity data.
- **Response**: The system processes the request and returns personalized recommendations to the user in near real-time.
- **Response Measure**: The system should respond to the user's request within 200 milliseconds, even under peak load conditions of up to 10,000 concurrent users.

### (c) Assuming the solution does not meet the response time requirements specified in (b), would it make sense to consider some form of prioritization of events?

Yes, it would make sense to consider some form of prioritization of events if the solution does not meet the response time requirements. Prioritization can help ensure that critical user requests, such as those for personalized recommendations, are processed more quickly than less urgent tasks, such as background data analysis or batch processing of global trending lists. This can help improve overall user experience and satisfaction by reducing latency for the most important interactions.

---

# Group IV

## 1. Suppose you need to implement a custom rule engine for generating product recommendations in SmartSuggest. Would it make sense to use a DSL for this purpose? Justify your answer and indicate whether an internal or external DSL would be more appropriate.

Using a Domain-Specific Language (DSL) for implementing a custom rule engine in SmartSuggest can be beneficial. A DSL allows domain experts to define recommendation rules in a language that is more intuitive and closer to the business domain, which can enhance collaboration between developers and domain experts. This can lead to more accurate and effective recommendation rules, as domain experts can directly contribute without needing deep programming knowledge. 
An internal DSL would be more appropriate in this case. An internal DSL can be built on top of an existing programming language, allowing developers to leverage the language's features and ecosystem while providing a specialized syntax for defining recommendation rules. This approach can facilitate easier integration with the existing codebase and reduce the learning curve for developers who are already familiar with the host language. Additionally, internal DSLs can be more flexible and easier to maintain compared to external DSLs, which require separate parsing and tooling.

---

## 2. SmartSuggest can be envisioned as a Software Product Line capable of supporting various configurations tailored to different customer needs. Every SmartSuggest system must include ingestion of user activity, recommendation generation and result presentation. Data ingestion can support real-time processing, batch processing or both. The recommendation types can be personalized or global trending lists, showing popular products system, with the option to combine both. The recommendation algorithms can be rule-based, relying on predefined business rules, ML-based, using machine-learning models or a hybrid approach combining both. Finally, result presentation can be done via web interfaces, mobile apps or APIs. These variability points have dependencies; for example, personalized recommendations require real-time ingestion.

### (a) Create a feature diagram representing the variability points described in SmartSuggest. Ensure it includes mandatory and optional features, as well as dependencies between them.


```
SmartSuggest
â”‚
â”œâ”€â”€ User Activity Ingestion (MANDATORY)
â”‚   â”œâ”€â”€ Real-Time Ingestion
â”‚   â”œâ”€â”€ Batch Ingestion
â”‚   â””â”€â”€ [Real-Time AND/OR Batch]
â”‚
â”œâ”€â”€ Recommendation Generation (MANDATORY)
â”‚   â”œâ”€â”€ Recommendation Type (MANDATORY)
â”‚   â”‚   â”œâ”€â”€ Personalized Recommendations
â”‚   â”‚   â”œâ”€â”€ Global Trending Recommendations
â”‚   â”‚   â””â”€â”€ [Personalized AND/OR Global Trending]
â”‚   â”‚
â”‚   â””â”€â”€ Recommendation Algorithm (MANDATORY)
â”‚       â”œâ”€â”€ Rule-Based
â”‚       â”œâ”€â”€ ML-Based
â”‚       â””â”€â”€ Hybrid (Rule-Based + ML-Based)
â”‚
â”œâ”€â”€ Result Presentation (MANDATORY)
â”‚   â”œâ”€â”€ Web Interface
â”‚   â”œâ”€â”€ Mobile App
â”‚   â””â”€â”€ API Access
â”‚   â””â”€â”€ [Web AND/OR Mobile AND/OR API]
```

**Dependencies / Constraints**

- Personalized Recommendations -> Real-Time Ingestion
- ML-Based Algorithms -> Real-Time Ingestion OR Batch Ingestion
- Hybrid Algorithm -> Rule-Based AND ML-Based
- Global Trending Recommendations -> Batch Ingestion
  
### (b) What are the advantages of managing SmartSuggest as a Software Product Line instead of developing independent systems for each configuration?

Managing SmartSuggest as a Software Product Line (SPL) offers several advantages over developing independent systems for each configuration:

- **Reusability**: SPL allows for the reuse of core components and features across different configurations, reducing development time and effort.
- **Consistency**: By managing a common codebase, SPL ensures that all configurations adhere to the same quality standards and architectural principles, leading to more reliable and maintainable systems.
- **Cost Efficiency**: Developing and maintaining a single product line is often more cost-effective than managing multiple independent systems, as it reduces duplication of effort and resources.
- **Faster Time-to-Market**: SPL enables quicker adaptation to market demands by allowing for rapid configuration and deployment of different system variants based on customer needs.
- **Easier Maintenance and Evolution**: Updates and improvements can be made to the core product line, benefiting all configurations simultaneously, simplifying maintenance and evolution of the system.
- **Better Management of Variability**: SPL provides structured mechanisms to manage variability, making it easier to handle different customer requirements and configurations systematically.