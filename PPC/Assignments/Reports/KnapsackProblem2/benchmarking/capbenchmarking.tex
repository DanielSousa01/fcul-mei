\chapter{Benchmarking}\label{cap:benchmarking}

\section{Go Implementation}
\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.7\textwidth]{benchmarking/images/go.png}
    \caption{Go Execution Times}
    \label{fig:go_execution_times}
\end{figure}

\begin{table}[htbp]
    \centering
    \begin{tabular}{|l|r|r|}
        \hline
        \textbf{Implementation} & \textbf{Time (ms)} & \textbf{Speedup} \\
        \hline
        Sequential & 72,728.21 & 1.00x \\
        \textbf{Goroutines} & \textbf{15,390.88} & \textbf{4.72x} \\
        Channels & 32,535.76 & 2.24x \\
        Actors & 32,849.94 & 2.21x \\
        \hline
    \end{tabular}
    \caption{Go Implementation Performance}
    \label{tab:go_performance}
\end{table}

\textbf{Best: Goroutines} - Lightweight concurrency with minimal overhead.

\newpage 

\section{Kotlin Implementation}
\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.7\textwidth]{benchmarking/images/kotlin.png}
    \caption{Kotlin Execution Times}
    \label{fig:kotlin_execution_times}
\end{figure}

\begin{table}[htbp]
    \centering
    \begin{tabular}{|l|r|r|}
        \hline
        \textbf{Implementation} & \textbf{Time (ms)} & \textbf{Speedup} \\
        \hline
        Sequential & 42,888.00 & 1.00x \\
        \textbf{Coroutines} & \textbf{9,513.00} & \textbf{4.51x} \\
        Channels & 34,285.00 & 1.25x \\
        Actors & 36,464.00 & 1.18x \\
        \hline
    \end{tabular}
    \caption{Kotlin Implementation Performance}
    \label{tab:kotlin_performance}
\end{table}

\textbf{Best: Coroutines} - Fastest sequential baseline and excellent parallel performance.

\newpage

\section{Rust Implementation}
\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.7\textwidth]{benchmarking/images/rust.png}
    \caption{Rust Execution Times}
    \label{fig:rust_execution_times}
\end{figure}

\begin{table}[htbp]
    \centering
    \begin{tabular}{|l|r|r|}
        \hline
        \textbf{Implementation} & \textbf{Time (ms)} & \textbf{Speedup} \\
        \hline
        Sequential & 58,100.71 & 1.00x \\
        Channels & 40,296.73 & 1.44x \\
        \textbf{Async Tasks} & \textbf{11,641.16} & \textbf{4.99x} \\
        \hline
    \end{tabular}
    \caption{Rust Implementation Performance}
    \label{tab:rust_performance}
\end{table}

\textbf{Best: Async Tasks} - Highest speedup using unsafe optimizations for zero-copy operations.

\newpage

\section{Kotlin Implementation (Assignment \#1)}
\begin{table}[htbp]
    \centering
    \begin{tabular}{|l|r|}
        \hline
        \textbf{Implementation} & \textbf{Speedup (16 threads)} \\
        \hline
        Master-Worker & \textbf{3.93x} \\
        Fork-Join (1k) & ~3.81x \\
        Scatter-Gather & ~3.86x \\
        \hline
    \end{tabular}
    \caption{Kotlin Implementation Performance}
    \label{tab:kotlin_performance_assignment1}
\end{table}

\textbf{Best: Master-Worker} - Persistent thread pool with efficient task distribution.

\section{Key Findings}

\subsection{Overall Performance Ranking}
\begin{enumerate}
    \item \textbf{Rust Async Tasks}: 4.99x speedup - Zero-copy optimizations
    \item \textbf{Go Goroutines}: 4.72x speedup - Lightweight concurrency primitives
    \item \textbf{Kotlin Coroutines}: 4.51x speedup - Efficient JVM-based coroutines
    \item \textbf{Kotlin Master-Worker}: 3.93x speedup - Traditional thread pool approach
\end{enumerate}

\subsection{Pattern Performance}
\begin{itemize}
    \item \textbf{Direct Parallelism} (Coroutines/Goroutines/Async): 4-5x speedup
    \item \textbf{Thread Pools} (Java patterns): 3-4x speedup
    \item \textbf{Message Passing} (Channels): 1.2-2.2x speedup 
    \item \textbf{Actors}: 1.2-2.2x speedup 
\end{itemize}

\subsection{Sequential Baseline Comparison}
\begin{itemize}
    \item \textbf{Fastest}: Kotlin (42,888 ms)
    \item \textbf{Middle}: Rust (58,101 ms)
    \item \textbf{Slowest}: Go (72,728 ms)
\end{itemize}

\section{Conclusion}

\textbf{Concurrency model matters more than language choice.} Direct parallelism approaches (coroutines, goroutines, async tasks) consistently outperform message-passing patterns by 2-3x across all languages.


